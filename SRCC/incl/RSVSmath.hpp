/**
 * Performs Volume and Area calculations for the RSVS process.
 *
 * This provides a simple(ish) interface to the "RSVSmath_automatic.hpp" header
 * which is auto generated by matlab's symbolic toolbox.
 *
 *@file
 */

#ifndef RSVSMATH_H_INCLUDED
#define RSVSMATH_H_INCLUDED

namespace param
{
namespace dev
{
class rsvseps;
}
} // namespace param

//=================================
// included dependencies
#include <cmath>
#include <vector>

#include "vectorarray.hpp"
/// \TODO refactor mesh.hpp into mesh and coord headers to allow smaller
/// includes
// needed for grid::coordlist (Things in mesh need a refactor)
#include "mesh.hpp"

//==================================
// Code
// NOTE: function in a class definition are IMPLICITELY INLINED
//       ie replaced by their code at compile time

class TriFunc
{
  protected:
    std::vector<double> const *p0 = NULL;
    std::vector<double> const *p1 = NULL;
    std::vector<double> const *p2 = NULL;

    double fun;
    ArrayVec<double> jac;
    ArrayVec<double> hes;

    bool isReady;
    bool isCalc;
    int nTarg; // target length of vectors

    bool MakeValidField(std::vector<double> *TriFunc::*mp);

  public:
    // Check validity
    bool CheckValid();
    bool MakeValid();
    void PreCalc();
    // Build a valid object
    void assign(const std::vector<double> &in0, const std::vector<double> &in1, const std::vector<double> &in2);
    void assign(const std::vector<double> *in0, const std::vector<double> *in1, const std::vector<double> *in2);
    void assign(int pRepI, const std::vector<double> &pRep);
    void ReturnDatPoint(double **a, ArrayVec<double> **b, ArrayVec<double> **c);
    virtual void Calc() = 0; // Virtual function that calculates

    TriFunc()
    {
        fun = 0;
        nTarg = 3;
        jac.assign(1, 3 * nTarg, fun);
        hes.assign(3 * nTarg, 3 * nTarg, fun);
        isReady = false;
        isCalc = false;
    }
    explicit TriFunc(int a)
    {
        nTarg = a;
        fun = 0;
        jac.assign(1, 3 * nTarg, fun);
        hes.assign(3 * nTarg, 3 * nTarg, fun);
        isReady = false;
        isCalc = false;
    }
};

class CoordFunc
{
  protected:
    grid::coordlist coords;

    double fun;
    ArrayVec<double> funA;
    ArrayVec<double> jac;
    ArrayVec<double> hes;

    bool isReady;
    bool isCalc;

    int nDim;   // target length of vectors
    int nCoord; // target length of vectors
    int nFun;

    bool MakeValidField(std::vector<double> const *mp);
    void InitialiseArrays();

  public:
    // Check validity
    bool CheckValid();
    bool MakeValid();
    void PreCalc();
    // Build a valid object
    void assign(grid::coordlist &coords);
    void assign(int pRepI, const std::vector<double> &pRep);
    void ReturnDat(double &a, ArrayVec<double> &b, ArrayVec<double> &c);
    void ReturnDat(ArrayVec<double> &a, ArrayVec<double> &b, ArrayVec<double> &c);
    void ReturnDatPoint(double **a, ArrayVec<double> **b, ArrayVec<double> **c);
    void ReturnDatPoint(ArrayVec<double> **a, ArrayVec<double> **b, ArrayVec<double> **c);
    virtual void Calc() = 0; // Virtual function that calculates the function

    void ResetDim(int n)
    {
        nDim = n;
        InitialiseArrays();
    }
    void ResetNCoord(int n)
    {
        nCoord = n;
        InitialiseArrays();
    }
    void ResetNFun(int n)
    {
        nFun = n;
        InitialiseArrays();
    }
    CoordFunc()
    {
        nDim = 3;
        nCoord = 3;
        nFun = 1;
        InitialiseArrays();
    }
    explicit CoordFunc(int n1)
    {
        nDim = n1;
        nCoord = 3;
        nFun = 1;
        InitialiseArrays();
    }
    CoordFunc(int n1, int n2)
    {
        nDim = n1;
        nCoord = n2;
        nFun = 1;
        InitialiseArrays();
    }

    CoordFunc(int n1, int n2, int n3)
    {
        nDim = n1;
        nCoord = n2;
        nFun = n3;
        InitialiseArrays();
    }
    ~CoordFunc()
    {
        coords.clear();
    }
};

class Volume : public TriFunc
{
    using TriFunc::fun;
    using TriFunc::hes;
    using TriFunc::jac;
    using TriFunc::p0;
    using TriFunc::p1;
    using TriFunc::p2;
    using TriFunc::PreCalc;
    using TriFunc::TriFunc;

  public:
    void Calc() override;
    void CalcFD();
};

class Area : public TriFunc
{
    using TriFunc::fun;
    using TriFunc::hes;
    using TriFunc::jac;
    using TriFunc::p0;
    using TriFunc::p1;
    using TriFunc::p2;
    using TriFunc::PreCalc;
    using TriFunc::TriFunc;

  public:
    void Calc() override;
};

class LengthEdge : public CoordFunc
{
    using CoordFunc::coords;
    using CoordFunc::fun;
    using CoordFunc::hes;
    using CoordFunc::jac;
    using CoordFunc::PreCalc;

  public:
    void Calc() override;
    LengthEdge() : CoordFunc(3, 2)
    {
    }
};

class Volume2 : public CoordFunc
{
    using CoordFunc::coords;
    using CoordFunc::fun;
    using CoordFunc::hes;
    using CoordFunc::jac;
    using CoordFunc::PreCalc;

  public:
    void Calc() override;
    Volume2() : CoordFunc(3, 7)
    {
    }
};

class SurfCentroid : public CoordFunc
{
  protected:
    // using CoordFunc::PreCalc;
    using CoordFunc::coords;
    using CoordFunc::fun;
    using CoordFunc::hes;
    using CoordFunc::jac;
    using CoordFunc::nCoord;

    std::vector<double> centroid;
    double edgeLength = 0.0;
    bool calcDeriv = true;

  public:
    void Disp();
    void Calc() override;
    void CalcFD();
    void assigncentroid(const std::vector<double> &vecin);

    const ArrayVec<double> &jac_ptr() const
    {
        return ((this->jac));
    };
    const ArrayVec<double> &hes_ptr() const
    {
        return ((this->hes));
    };

    SurfCentroid() : CoordFunc(3, 4, 3)
    {
        centroid.assign(nDim, 0);
    };
    explicit SurfCentroid(int a) : CoordFunc(3, a, 3)
    {
        nCoord = a;
        centroid.assign(nDim, 0);
    };
};

void SetEnvironmentEpsilon(const param::dev::rsvseps &rsvsEpsilons);

int Test_SurfCentreDerivatives();

#endif
